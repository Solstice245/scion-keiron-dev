//==================================================================================================
//  Melee AI Functions only used by the lower difficulties.
//==================================================================================================

const int c_ldPhaseNone   = 0;
const int c_ldPhaseOpen   = 1;
const int c_ldPhaseMid    = 2;
const int c_ldPhaseLate   = 3;
const int c_ldPhaseFinal  = 4;

const int c_ldMaxArmyStockSize = 32;
const fixed c_ldArmyStockScale = 1000.0;
const int c_ldArmyRoundUp = 500; //FixedToInt(c_ldArmyStockScale/2.0);

//--------------------------------------------------------------------------------------------------
//  AILowDifficultyInit
//--------------------------------------------------------------------------------------------------
void AILowDifficultyInit (int player) {
    int diff = AIPlayerDifficulty(player);

    if (diff < c_skirVeryEasy || diff > c_skirHard)  {
        return;
    }

    AISetStockArmyDefaultScale(player, c_ldArmyStockScale);
}

//--------------------------------------------------------------------------------------------------
//  AIClearStockArmy
//--------------------------------------------------------------------------------------------------
void AIClearStockArmy (int player) {
    int index = 1;
    while (index <= c_ldMaxArmyStockSize) {
        AISetUserString(player, index, c_nullString);
        AISetUserInt(player, index, 0);
        index = index + 1;
    }
}

//--------------------------------------------------------------------------------------------------
//  AISetStockArmyScale
//--------------------------------------------------------------------------------------------------
void AISetStockArmyScale (int player, fixed scale) {
    int index = 1;
    int count;

    scale /= c_ldArmyStockScale;

    while (index < c_ldMaxArmyStockSize) {
        count = AIGetUserInt(player, index);
        if (count <= 0) {
            break;
        }
        // add "0.5" so we'll round to the nearest value
        count += c_ldArmyRoundUp;

        count = FixedToInt(IntToFixed(count) * scale);

        if (count > 0) {
            AISetStock(player, count, AIGetUserString(player, index));
        }
        index = index + 1;
    }
    if (index >= c_ldMaxArmyStockSize) {
        if (AIGetUserInt(player, index) > 0) {
            ErrorMeleeScript(player, "AISetStockArmy too much data");
        }
    }
}


//--------------------------------------------------------------------------------------------------
//  AIGetStockArmyCount
//--------------------------------------------------------------------------------------------------
int AIGetStockArmyCount (int player) {
    int index = 1;
    int count;
    int total;

    while (index < c_ldMaxArmyStockSize) {
        count = AIGetUserInt(player, index);
        if (count <= 0) {
            break;
        }
        // add "0.5" so we'll round to the nearest value
        count += c_ldArmyRoundUp;

        count = FixedToInt(IntToFixed(count) / c_ldArmyStockScale);

        total += count;

        index = index + 1;
    }
    if (index >= c_ldMaxArmyStockSize) {
        if (AIGetUserInt(player, index) > 0) {
            ErrorMeleeScript(player, "AISetStockArmy too much data");
        }
    }

    return total;
}

//--------------------------------------------------------------------------------------------------
//  AITestTimeout
//--------------------------------------------------------------------------------------------------
bool AITestTimeout (int player, int timeOut, int nextState, int nextSubState) {
    bool sendAttack = true;
    int waveCount;
    int desiredArmyCount;
    if (AIGetTime() < timeOut) {
        return false;
    }

    if (AIState(player, e_mainState) == e_mainState_Open) {
        if (AIGetUserInt(player, c_openingBuildType) == e_buildType_Macro) {
            // macro build doesn't attack between open & mid
            sendAttack = false;
        }
    }
    if (sendAttack) {
        waveCount = AIWaveUnitCount(AIWaveGet(player, c_waveMain)) + AIWaveUnitCount(AIWaveGet(player, c_waveAttack));
        desiredArmyCount = AIGetStockArmyCount(player);

        if (waveCount < desiredArmyCount/2) {
            // army if less than half the size we wanted, don't bother to send it
            sendAttack = false;
        }
    }

    if (sendAttack) {
        AIWaveMerge(player, c_waveMain, c_waveAttack);
        AISetAttackState(player, e_attackState_Attack);
    }

    AISetMainState(player, nextState, nextSubState);
    AIClearStockArmy(player);

    return true;
}

//--------------------------------------------------------------------------------------------------
void AILDGeneralSharedLogic (int player) {
    bool activateNextWave;

    //scouting logic
    if (AIGetNumWorkers(player) >= 6) {
        if (PlayerBeaconIsSet(player, c_beaconScout)) {
            AISetFlag(player, e_flagsScouting, true);
        }
        else if (AIGetTime() > 300) {
            AISetFlag(player, e_flagsScouting, true);
        }
        else if (AIGetTime() > 40 && AIHasHumanAlly(player)) {
            AISetFlag(player, e_flagsScouting, true);
        }
    }

    // coop attacker logic
    if (AIGetCoopFlag(player, c_coopWaveAttacker)) {
        if (AIGetTime() > 330) {
            if (AIState(player, e_attackState) == e_attackState_Wait) {
                AISetAttackState(player, e_attackState_Attack);
            }
        }

        activateNextWave = true;
        if (AIState(player, e_attackState) == e_attackState_Wait) {
            activateNextWave = false; // wait for the AI to activate
        }
        if (AIWaveUnitCount(AIWaveGet(player, c_waveAttack)) > 0) {
            activateNextWave = false;
        }
        else if (AIWaveUnitCount(AIWaveGet(player, c_waveMain)) < 8) {
            activateNextWave = false;
        }

        if (activateNextWave) {
            AIWaveMerge(player, c_waveMain, c_waveAttack);
        }
    }
}

//--------------------------------------------------------------------------------------------------
//  AIPickFrom2
//--------------------------------------------------------------------------------------------------
string AIPickFrom2 (string a, string b) {
    int roll = RandomInt(1,2);
    if (roll == 1) {
        return a;
    }
    return b;
}

//--------------------------------------------------------------------------------------------------
//  AIPickFrom3
//--------------------------------------------------------------------------------------------------
string AIPickFrom3 (string a, string b, string c) {
    int roll = RandomInt(1,3);
    if (roll == 1) {
        return a;
    }
    if (roll == 2) {
        return b;
    }
    return c;
}

//--------------------------------------------------------------------------------------------------
//  AIAddToStockArmyPickFrom2Count
//--------------------------------------------------------------------------------------------------
void AIAddToStockArmyPickFrom2Count (int player, string a, int anum, string b, int bnum) {
    int roll = RandomInt(1,2);
    if (roll == 1) {
        AIAddToStockArmy(player, a, anum);
    } else {
        AIAddToStockArmy(player, b, bnum);
    }
}

//--------------------------------------------------------------------------------------------------
//  AIAddToStockArmyPickFrom3Count
//--------------------------------------------------------------------------------------------------
void AIAddToStockArmyPickFrom3Count (int player, string a, int anum, string b, int bnum, string c, int cnum) {
    int roll = RandomInt(1,3);
    if (roll == 1) {
        AIAddToStockArmy(player, a, anum);
    } else if (roll == 2) {
        AIAddToStockArmy(player, b, bnum);
    } else {
        AIAddToStockArmy(player, c, cnum);
    }
}

//--------------------------------------------------------------------------------------------------
//  AIGetWorkerDelay
//--------------------------------------------------------------------------------------------------
int AIGetWorkerDelay (int player) {
    int diff = AIPlayerDifficulty(player); 
    if (diff == c_skirVeryEasy) {
        return 10;
    }
    if (diff == c_skirEasy) {
        return 6;
    }
    if (diff == c_skirMedium) {
        return 4;
    }
    if (diff == c_skirMed_Hard) {
        return 2;
    }

    return 0;
}

//--------------------------------------------------------------------------------------------------
//  AIGetDefenseDelay
//--------------------------------------------------------------------------------------------------
int AIGetDefenseDelay (int player) {
    int diff = AIPlayerDifficulty(player); 
    if (diff == c_skirVeryEasy) {
        return 40;
    }
    if (diff == c_skirEasy) {
        return 20;
    }
    if (diff == c_skirMedium) {
        return 10;
    }
    if (diff == c_skirMed_Hard) {
        return 5;
    }

    return 0;
}

//--------------------------------------------------------------------------------------------------
//  AIGetArmyDelay
//--------------------------------------------------------------------------------------------------
int AIGetArmyDelay (int player, int duration, int phase) {
    int armyCount = AIGetStockArmyCount(player);
    int buildType = AIGetUserInt(player, c_openingBuildType);
    int timePerUnit;

    if (armyCount == 0) {
        ErrorMeleeScript(player, "AIGetArmyDelay no army?");
        return 0;
    }

    // Subtract off 150 seconds from the duration. This gives us time to build the initial tech 
    //   buildings we might need first and to ensure the last unit finishes in time.
    duration -= 150;
    if (phase == c_ldPhaseOpen) {
        duration -= 150; // If this is the start of the game, subtract off 150 seconds for the initial ramp up.
        if (buildType == e_buildType_Air) {
            duration -= 180; // If this is an air build, subtract off another 180 seconds for additional ramp up.
        }
        else if (buildType == e_buildType_Macro) {
            duration -= 60; // If this is a macro build, subtract off another 60 seconds for additional ramp up.
        }
    }

    timePerUnit = duration / (armyCount + 1); // increase army count by one to ensure last unit is done in time 
    if (timePerUnit < 3) {
        return 0; // handles small and negative cases.
    }

    return timePerUnit;
}

//--------------------------------------------------------------------------------------------------
//  AISetupNextArmyStock
//--------------------------------------------------------------------------------------------------
int TemplateArmySetup(int player, int buildType);  // set up the next army, return duration

void AISetupNextArmy (int player, int buildType, int newPhase, funcref<TemplateArmySetup> armyFunc ) {
    int origPhase = AIGetUserInt(player, c_ldNextArmyPhase);
    int origDuration = AIGetUserInt(player, c_ldNextArmyDuration);
    int origEndTime = AIGetUserInt(player, c_nextArmyTime);
    int origStartTime = 0;
    fixed origTimeElapsed = 0.0;
    fixed percentElapsed = 0.0;
    fixed percentRemaining = 0.0;
    int newDuration;
    int newEndTime;
    int armyCount;

    if (newPhase == origPhase) {
        // switching due to player request
        origStartTime = origEndTime - origDuration;
        origTimeElapsed = AIGetTime() - IntToFixed(origStartTime);
        if (origTimeElapsed > origDuration - 1) {
            origTimeElapsed = origDuration - 1;
        }
        percentElapsed = origTimeElapsed / IntToFixed(origDuration);
        percentRemaining = 1.0 - percentElapsed;
        if (percentRemaining < 0.01) {
            percentRemaining = 0.01;
        }

        AIScaleCurrentStockArmy(player, percentElapsed / percentRemaining, 0, c_ldMaxArmyStockSize-1);
    } else {
        // switching to next phase
        AIClearStockArmy(player);
    }

    // add new army stock
    newDuration = armyFunc(player, buildType);
    if (newDuration < 60) {
        ErrorMeleeScript(player, "AISetupNextArmy bogus duration?");
        newDuration = 60;
    }

    if (newPhase == origPhase) {
        // switching due to player request
        if (newDuration < origDuration) {
            newDuration = FixedToInt(IntToFixed(newDuration) * percentRemaining);
            newDuration += FixedToInt(IntToFixed(origDuration) * percentElapsed);
        }

        newEndTime = origStartTime + newDuration;
        
        AIScaleCurrentStockArmy(player, percentRemaining, 0, c_ldMaxArmyStockSize-1);
    } else {
        // switching to next phase
        newEndTime = FixedToInt(AIGetTime()) + newDuration;
    }

    // set wave values
    AISetUserInt(player, c_ldNextArmyPhase, newPhase);
    AISetUserInt(player, c_ldNextArmyDuration, newDuration);
    AISetUserInt(player, c_nextArmyTime, newEndTime);

    // set training delay values
    AIForceTrainingDelay(player, AIGetWorkerDelay(player), AIGetArmyDelay(player, newDuration, newPhase), AIGetDefenseDelay(player));
}

//--------------------------------------------------------------------------------------------------
//  AILDStockWorkers
//--------------------------------------------------------------------------------------------------
void AILDStockWorkers (int player, int count, string worker) {
    int econMin = AIGetMinPeonCount(player, c_townMax);
    int econMax = AIGetMaxPeonCount(player, c_townMax);

    if (econMin > count) {
        count = econMin;
    } 
    else if (econMax < count) {
        count = econMax;
    }

    AISetStockUnitNext( player, count, worker, c_stockAlways );
}

//--------------------------------------------------------------------------------------------------
//  GenetronBasicEconomy
//--------------------------------------------------------------------------------------------------
void GenetronBasicEconomy (int player, int tier, int minWorkers) {
    int econMin = AIGetMinPeonCount(player, c_townMax);
    if (minWorkers > econMin) {
        minWorkers = econMin;
    }

    AIDefaultEconomy(player, c_GB_ProcessingCore, c_GB_FilteringPlant, c_GB_Node, c_GU_ACR, minWorkers, c_stockAlways);
}

//--------------------------------------------------------------------------------------------------
//  GenetronBasicExpansion
//--------------------------------------------------------------------------------------------------
void GenetronBasicExpansion (int player, int tier, int minerals, int gas) {
    AIDefaultExpansion(player, c_GB_ProcessingCore, minerals, gas, c_expandDefault);
}

//--------------------------------------------------------------------------------------------------
//  GenetronGeneralBuild
//--------------------------------------------------------------------------------------------------
void GenetronGeneralBuild (int player, int tier) {
    if (tier >= c_ldPhaseMid) {
        if (PlayerBeaconIsSet(player, c_beaconDetect)) {
            AISetStock( player, 1, c_GU_Processor );
        }
    }
}

//--------------------------------------------------------------------------------------------------
//  GenetronMacroExpand
//--------------------------------------------------------------------------------------------------
bool GenetronMacroExpand (int player) {
    fixed defenseEval = 0;

    if (AITechCount(player, c_GU_ACR, c_techCountQueuedOrBetter) < 14) {
        return false;
    }
    if (AITechCount(player, c_GB_ProcessingCore, c_techCountQueuedOrBetter) >= 2) {
        return false;
    }
    
    defenseEval = AISelfDefenseThreatEval(c_dtRealSelfThreat, player);
    if (defenseEval >= 120) {
        // don't expand if currently under attack
        return false;
    }

    if (!AIIsExpandingOrHasExpanded(player)) {
        if (!AIHasNearbyOpenExpansion(player)) {
            return false;
        }
        if (!AIHasRes(player,300,0)) {
            AIEnableStock(player);
            return true;
        }

        // we should try to expand
        AIExpand(player, AIGetTownLocation(player, c_townMain), c_GB_ProcessingCore);
    }

    // currently expanding see if we need to save minerals
    if (!AIHasRes(player,500,0)) {
        AIEnableStock(player);
        return true;
    }
    return false; // already saved enough, we're allowed to continure the stock
}

//--------------------------------------------------------------------------------------------------
//  GenetronAtEachTown
//--------------------------------------------------------------------------------------------------
void GenetronAtEachTown (int player, int tier) {
    int i = 0;
    int town;

    while (i < c_townMax) {
        town = i;
        i = i + 1;

        if (AIGetTownState(player, town) != c_townStateEstablished) {
            continue;
        }

        if (AIGetBuildingCountInTown(player, town, c_GB_ProcessingCore, c_techCountCompleteOnly) < 1) {
            continue;
        }

        if (AIGetBuildingCountInTown(player, town, c_GB_Interdictor_Alias, c_techCountCompleteOnly) < 2) {
            AISetStockEx(player, town, 2, c_GB_Interdictor_Alias, c_makeResourceDefense | c_nearDropoff, 0);
            continue;
        }
        if (AIGetBuildingCountInTown(player, town, c_GB_Repulsor_Alias, c_techCountCompleteOnly) < 1) {
            AISetStockEx(player, town, 1, c_GB_Repulsor_Alias, c_makeResourceDefense | c_nearDropoff, 0);
            continue;
        }
    }
}

//--------------------------------------------------------------------------------------------------
//  GenetronTechUp
//--------------------------------------------------------------------------------------------------
void GenetronTechUp (int player, int tier) {
    int diff = AIPlayerDifficulty(player);

    if (diff < c_skirMedium) {
        // don't build extra buildings below medium
        return;
    }

    AISetStock( player, 2, c_GB_FilteringPlant );
    AISetStock( player, 1, c_GB_Manufacturer );
    AISetStock( player, 2, c_GB_Uploader );
    AISetStock( player, 1, c_GB_OutfittingStation );

    if (tier >= c_ldPhaseMid) {
        GenetronAtEachTown(player, tier);
        AISetStock( player, 1, c_GB_Fabricator );
        AISetStock( player, 1, c_GB_TechVault );
        AISetStock( player, 1, c_GB_AssemblyArray );
        AISetStock( player, 3, c_GB_Manufacturer );
        AISetStock( player, 12, c_GB_Uploader );

        if (tier >= c_ldPhaseLate) {
            AISetStock( player, 1, c_GB_AnalysisTerminal );
            AISetStock( player, 2, c_GB_OutfittingStation );
            AISetStock( player, 2, c_GB_TechVault );
            AISetStock( player, 2, c_GB_AssemblyArray );
            AISetStock( player, 18, c_GB_Uploader );
        }
    }
}

//--------------------------------------------------------------------------------------------------
//  XayidBasicEconomy
//--------------------------------------------------------------------------------------------------
void XayidBasicEconomy (int player, int tier, int minWorkers) {
    int econMin = AIGetMinPeonCount(player, c_townMax);
    if (minWorkers > econMin) {
        minWorkers = econMin;
    }

    AIDefaultEconomy(player, c_XB_ScavengerNest, c_XB_Siphoner, c_XB_FeedingPool, c_XU_Scavenger, minWorkers, c_stockAlways);
}

//--------------------------------------------------------------------------------------------------
//  XayidBasicExpansion
//--------------------------------------------------------------------------------------------------
void XayidBasicExpansion (int player, int tier, int minerals, int gas) {
    AIDefaultExpansion(player, c_XB_ScavengerNest, minerals, gas, c_expandDefault);
}

//--------------------------------------------------------------------------------------------------
//  XayidGeneralBuild
//--------------------------------------------------------------------------------------------------
void XayidGeneralBuild (int player, int tier) {
    if (tier >= c_ldPhaseMid) {
        if (PlayerBeaconIsSet(player, c_beaconDetect)) {
            AISetStock( player, 1, c_XU_Ferrion );
        }
    }
}

//--------------------------------------------------------------------------------------------------
//  XayidMacroExpand
//--------------------------------------------------------------------------------------------------
bool XayidMacroExpand (int player) {
    fixed defenseEval = 0;

    if (AITechCount(player, c_XU_Scavenger, c_techCountQueuedOrBetter) < 14) {
        return false;
    }
    if (AITechCount(player, c_XB_ScavengerNest, c_techCountQueuedOrBetter) >= 2) {
        return false;
    }
    
    defenseEval = AISelfDefenseThreatEval(c_dtRealSelfThreat, player);
    if (defenseEval >= 120) {
        // don't expand if currently under attack
        return false;
    }

    if (!AIIsExpandingOrHasExpanded(player)) {
        if (!AIHasNearbyOpenExpansion(player)) {
            return false;
        }
        if (!AIHasRes(player,300,0)) {
            AIEnableStock(player);
            return true;
        }

        // we should try to expand
        AIExpand(player, AIGetTownLocation(player, c_townMain), c_XB_ScavengerNest);
    }

    // currently expanding see if we need to save minerals
    if (!AIHasRes(player,500,0)) {
        AIEnableStock(player);
        return true;
    }
    return false; // already saved enough, we're allowed to continure the stock
}

//--------------------------------------------------------------------------------------------------
//  XayidAtEachTown
//--------------------------------------------------------------------------------------------------
void XayidAtEachTown (int player, int tier) {
    int i = 0;
    int town;

    while (i < c_townMax) {
        town = i;
        i = i + 1;

        if (AIGetTownState(player, town) != c_townStateEstablished) {
            continue;
        }

        if (AIGetBuildingCountInTown(player, town, c_XB_ScavengerNest, c_techCountCompleteOnly) < 1) {
            continue;
        }

        if (AIGetBuildingCountInTown(player, town, c_XB_BilePit, c_techCountCompleteOnly) < 3) {
            AISetStockEx(player, town, 3, c_XB_BilePit, c_makeResourceDefense | c_nearDropoff, 0);
            continue;
        }
    }
}

//--------------------------------------------------------------------------------------------------
//  XayidTechUp
//--------------------------------------------------------------------------------------------------
void XayidTechUp (int player, int tier) {
    int diff = AIPlayerDifficulty(player);

    if (diff < c_skirMedium) {
        // don't build extra buildings below medium
        return;
    }

    AISetStock( player, 2, c_XB_Siphoner );
    AISetStock( player, 1, c_XB_XayidDen );
    AISetStock( player, 1, c_XB_MutagenChamber );

    if (tier >= c_ldPhaseMid) {
        XayidAtEachTown(player, tier);
        AISetStock( player, 1, c_XB_BiomassHatchery );
        AISetStock( player, 1, c_XB_BiomassCavern );
        AISetStock( player, 1, c_XB_AvianNest );
        AISetStock( player, 1, c_XB_CatalystPit );
        AISetStock( player, 1, c_XB_CasnoliskDen );
        AISetStock( player, 3, c_XB_XayidDen );

        if (tier >= c_ldPhaseLate) {
            AISetStock( player, 1, c_XB_SunkenWarren );
            AISetStock( player, 2, c_XB_MutagenChamber );
            AISetStock( player, 2, c_XB_CatalystPit );
            AISetStock( player, 2, c_XB_AvianNest );
        }
    }
}

//--------------------------------------------------------------------------------------------------
//  KeironBasicEconomy
//--------------------------------------------------------------------------------------------------
void KeironBasicEconomy (int player, int tier, int minWorkers) {
    int econMin = AIGetMinPeonCount(player, c_townMax);
    if (minWorkers > econMin) {
        minWorkers = econMin;
    }

    AIDefaultEconomy(player, c_KB_Citadel_Alias, c_KB_Formulator, c_KB_Edifice, c_KU_Converter, minWorkers, c_stockAlways);
}

//--------------------------------------------------------------------------------------------------
//  KeironBasicExpansion
//--------------------------------------------------------------------------------------------------
void KeironBasicExpansion (int player, int tier, int minerals, int gas) {
    AIDefaultExpansion(player, c_KB_Citadel, minerals, gas, c_expandDefault);
}

//--------------------------------------------------------------------------------------------------
//  KeironGeneralBuild
//--------------------------------------------------------------------------------------------------
void KeironGeneralBuild (int player, int tier) {
    if (tier >= c_ldPhaseMid) {
        if (PlayerBeaconIsSet(player, c_beaconDetect)) {
            AISetStock( player, 1, c_KU_Paradox );
        }
    }
}

//--------------------------------------------------------------------------------------------------
//  KeironMacroExpand
//--------------------------------------------------------------------------------------------------
bool KeironMacroExpand (int player) {
    fixed defenseEval = 0;

    if (AITechCount(player, c_KU_Converter, c_techCountQueuedOrBetter) < 14) {
        return false;
    }
    if (AITechCount(player, c_KB_Citadel_Alias, c_techCountQueuedOrBetter) >= 2) {
        return false;
    }
    
    defenseEval = AISelfDefenseThreatEval(c_dtRealSelfThreat, player);
    if (defenseEval >= 120) {
        // don't expand if currently under attack
        return false;
    }

    if (!AIIsExpandingOrHasExpanded(player)) {
        if (!AIHasNearbyOpenExpansion(player)) {
            return false;
        }
        if (!AIHasRes(player,300,0)) {
            AIEnableStock(player);
            return true;
        }

        // we should try to expand
        AIExpand(player, AIGetTownLocation(player, c_townMain), c_KB_Citadel);
    }

    // currently expanding see if we need to save minerals
    if (!AIHasRes(player,500,0)) {
        AIEnableStock(player);
        return true;
    }
    return false; // already saved enough, we're allowed to continue the stock
}

//--------------------------------------------------------------------------------------------------
//  KeironAtEachTown
//--------------------------------------------------------------------------------------------------
void KeironAtEachTown (int player, int tier) {
    int i = 0;
    int town;

    while (i < c_townMax) {
        town = i;
        i = i + 1;

        if (AIGetTownState(player, town) != c_townStateEstablished) {
            continue;
        }

        if (AIGetBuildingCountInTown(player, town, c_KB_Citadel_Alias, c_techCountCompleteOnly) < 1) {
            continue;
        }

        if (AIGetBuildingCountInTown(player, town, c_KB_Stratus, c_techCountCompleteOnly) < 2) {
            AISetStockEx(player, town, 2, c_KB_Stratus, c_makeResourceDefense | c_nearDropoff, 0);
            continue;
        }
        if (AIGetBuildingCountInTown(player, town, c_KB_Nullifier, c_techCountCompleteOnly) < 1) {
            AISetStockEx(player, town, 1, c_KB_Nullifier, c_makeResourceDefense | c_nearDropoff, 0);
            continue;
        }
    }
}

//--------------------------------------------------------------------------------------------------
//  KeironTechUp
//--------------------------------------------------------------------------------------------------
void KeironTechUp (int player, int tier) {
    int diff = AIPlayerDifficulty(player);

    if (diff < c_skirMedium) {
        // don't build extra buildings below medium
        return;
    }

    AISetStock( player, 2, c_KB_Formulator );
    AISetStock( player, 1, c_KB_Edifice );
    AISetStock( player, 1, c_KB_Sanctum );
    AISetStock( player, 1, c_KB_Reliquary );

    if (tier >= c_ldPhaseMid) {
        KeironAtEachTown(player, tier);
        AISetStock( player, 1, c_KB_Foundry );
        AISetStock( player, 1, c_KB_Atrium );
        AISetStock( player, 1, c_KB_Oculus );
        AISetStock( player, 2, c_KB_Reliquary );
        AISetStock( player, 1, c_KB_Conduit );
        AISetStock( player, 1, c_KB_Outlet );
        AISetStock( player, 4, c_KB_Edifice );
        AISetStock( player, 2, c_KB_Sanctum );

        if (tier >= c_ldPhaseLate) {
            AISetStock( player, 1, c_KB_Elysium );
            AISetStock( player, 1, c_KB_Pantheon );
            AISetStock( player, 5, c_KB_Reliquary );
            AISetStock( player, 2, c_KB_Foundry );
            AISetStock( player, 2, c_KB_Empyrean );
            AISetStock( player, 1, c_KB_Zenith );
        }
    }
}

//--------------------------------------------------------------------------------------------------
//  TerranBasicEconomy
//--------------------------------------------------------------------------------------------------
void TerranBasicEconomy (int player, int tier, int minWorkers) {
    int econMin = AIGetMinPeonCount(player, c_townMax);
    if (minWorkers > econMin) {
        minWorkers = econMin;
    }

    AIDefaultEconomy(player, c_TB_CommandCenter_Alias, c_TB_Refinery, c_TB_SupplyDepot, c_TU_SCV, minWorkers, c_stockAlways);
}

//--------------------------------------------------------------------------------------------------
//  TerranBasicExpansion
//--------------------------------------------------------------------------------------------------
void TerranBasicExpansion (int player, int tier, int minerals, int gas) {
    AIDefaultExpansion(player, c_TB_CommandCenter, minerals, gas, c_expandDefault);
}

//--------------------------------------------------------------------------------------------------
//  TerranGeneralBuild
//--------------------------------------------------------------------------------------------------
void TerranGeneralBuild (int player, int tier) {
    if (tier >= c_ldPhaseMid) {
        if (PlayerBeaconIsSet(player, c_beaconDetect)) {
            AISetStock( player, 1, c_TU_Raven );
        }
    }
}

//--------------------------------------------------------------------------------------------------
//  TerranMacroExpand
//--------------------------------------------------------------------------------------------------
bool TerranMacroExpand (int player) {
    fixed defenseEval = 0;

    if (AITechCount(player, c_TU_SCV, c_techCountQueuedOrBetter) < 14) {
        return false;
    }
    if (AITechCount(player, c_TB_CommandCenter_Alias, c_techCountQueuedOrBetter) >= 2) {
        return false;
    }
    
    defenseEval = AISelfDefenseThreatEval(c_dtRealSelfThreat, player);
    if (defenseEval >= 120) {
        // don't expand if currently under attack
        return false;
    }

    if (!AIIsExpandingOrHasExpanded(player)) {
        if (!AIHasNearbyOpenExpansion(player)) {
            return false;
        }
        if (!AIHasRes(player,300,0)) {
            AIEnableStock(player);
            return true;
        }

        // we should try to expand
        AIExpand(player, AIGetTownLocation(player, c_townMain), c_TB_CommandCenter);
    }

    // currently expanding see if we need to save minerals
    if (!AIHasRes(player,500,0)) {
        AIEnableStock(player);
        return true;
    }
    return false; // already saved enough, we're allowed to continure the stock
}

//--------------------------------------------------------------------------------------------------
//  TerranAtEachTown
//--------------------------------------------------------------------------------------------------
void TerranAtEachTown (int player, int tier) {
    int i = 0;
    int town;

    while (i < c_townMax) {
        town = i;
        i = i + 1;

        if (AIGetTownState(player, town) != c_townStateEstablished) {
            continue;
        }

        if (AIGetBuildingCountInTown(player, town, c_TB_CommandCenter_Alias, c_techCountCompleteOnly) < 1) {
            continue;
        }

        if (AIGetBuildingCountInTown(player, town, c_TB_MissileTurret, c_techCountCompleteOnly) < 2) {
            AISetStockEx(player, town, 2, c_TB_MissileTurret, c_makeResourceDefense | c_nearDropoff, 0);
            continue;
        }
        if (AIGetBuildingCountInTown(player, town, c_TB_Bunker, c_techCountCompleteOnly) < 1) {
            AISetStockEx(player, town, 1, c_TB_Bunker, c_makeResourceDefense | c_nearDropoff, 0);
            continue;
        }
    }
}

//--------------------------------------------------------------------------------------------------
//  TerranTechUp
//--------------------------------------------------------------------------------------------------
void TerranTechUp (int player, int tier) {
    int diff = AIPlayerDifficulty(player);

    if (diff < c_skirMedium) {
        // don't build extra buildings below medium
        return;
    }

    AISetStock( player, 2, c_TB_Refinery );
    AISetStock( player, 1, c_TB_Barracks );
    AISetStock( player, 1, c_TB_BarracksTechLab );
    AISetStock( player, 1, c_TB_EngineeringBay );

    if (tier >= c_ldPhaseMid) {
        TerranAtEachTown(player, tier);
        AISetStock( player, 1, c_TB_Factory );
        AISetStock( player, 1, c_TB_FactoryTechLab );
        AISetStock( player, 1, c_TB_SensorTower );
        AISetStock( player, 1, c_TB_Armory );
        AISetStock( player, 1, c_TB_Starport );
        AISetStock( player, 1, c_TB_StarportTechLab );
        AISetStock( player, 3, c_TB_Barracks );
        AISetStock( player, 2, c_TB_BarracksTechLab );
        AISetStock( player, 1, c_TB_BarracksReactor );

        if (tier >= c_ldPhaseLate) {
            AISetStock( player, 1, c_TB_GhostAcademy );
            AISetStock( player, 1, c_TB_FusionCore );
            AISetStock( player, 2, c_TB_EngineeringBay );
            AISetStock( player, 2, c_TB_Armory );
            AISetStock( player, 2, c_TB_Factory );
            AISetStock( player, 1, c_TB_FactoryReactor );
            AISetStock( player, 2, c_TB_Starport );
            AISetStock( player, 1, c_TB_StarportReactor );
        }
    }
}

//--------------------------------------------------------------------------------------------------
//  ZergBasicEconomy
//--------------------------------------------------------------------------------------------------
void ZergBasicEconomy (int player, int tier, int minWorkers) {
    int econMin = AIGetMinPeonCount(player, c_townMax);
    if (minWorkers > econMin) {
        minWorkers = econMin;
    }

    AIDefaultEconomy(player, c_ZB_Hatchery_Alias, c_ZB_Extractor, c_ZU_Overlord, c_ZU_Drone, minWorkers, c_stockAlways);
    AISetStock( player, 1, c_ZU_Queen );
}

//--------------------------------------------------------------------------------------------------
//  ZergBasicExpansion
//--------------------------------------------------------------------------------------------------
void ZergBasicExpansion (int player, int tier, int minerals, int gas) {
    AIDefaultExpansion(player, c_ZB_Hatchery, minerals, gas, c_expandDefault);
}

//--------------------------------------------------------------------------------------------------
//  ZergGeneralBuild
//--------------------------------------------------------------------------------------------------
void ZergGeneralBuild (int player, int tier) {
    if (tier >= c_ldPhaseMid) {
        if (PlayerBeaconIsSet(player, c_beaconDetect)) {
            AISetStock( player, 1, c_ZU_Overseer );
        }
    }
}

//--------------------------------------------------------------------------------------------------
//  ZergMacroExpand
//--------------------------------------------------------------------------------------------------
bool ZergMacroExpand (int player) {
    fixed defenseEval = 0;

    if (AITechCount(player, c_ZU_Drone, c_techCountQueuedOrBetter) < 13) {
        return false;
    }
    if (AITechCount(player, c_ZB_Hatchery_Alias, c_techCountQueuedOrBetter) >= 2) {
        return false;
    }
    
    defenseEval = AISelfDefenseThreatEval(c_dtRealSelfThreat, player);
    if (defenseEval >= 120) {
        // don't expand if currently under attack
        return false;
    }

    if (!AIIsExpandingOrHasExpanded(player)) {
        if (!AIHasNearbyOpenExpansion(player)) {
            return false;
        }
        if (!AIHasRes(player,200,0)) {
            AIEnableStock(player);
            return true;
        }

        // we should try to expand
        AIExpand(player, AIGetTownLocation(player, c_townMain), c_ZB_Hatchery);
    }

    // currently expanding see if we need to save minerals
    if (!AIHasRes(player,400,0)) {
        AIEnableStock(player);
        return true;
    }
    return false; // already saved enough, we're allowed to continure the stock
}

//--------------------------------------------------------------------------------------------------
//  ZergAtEachTown
//--------------------------------------------------------------------------------------------------
void ZergAtEachTown (int player, int tier) {
    int i = 0;
    int town;
    int numTowns = 0;

    while (i < c_townMax) {
        town = i;
        i = i + 1;

        if (AIGetTownState(player, town) != c_townStateEstablished) {
            continue;
        }

        if (AIGetBuildingCountInTown(player, town, c_ZB_Hatchery_Alias, c_techCountCompleteOnly) < 1) {
            continue;
        }

        numTowns += 1;

        if (AIGetBuildingCountInTown(player, town, c_ZB_SporeCrawler, c_techCountCompleteOnly) < 2) {
            AISetStockEx(player, town, 2, c_ZB_SporeCrawler, c_makeResourceDefense | c_nearDropoff, 0);
            continue;
        }
        if (AIGetBuildingCountInTown(player, town, c_ZB_SpineCrawler, c_techCountCompleteOnly) < 2) {
            AISetStockEx(player, town, 2, c_ZB_SpineCrawler, c_makeResourceDefense | c_nearDropoff, 0);
            continue;
        }
    }

    AISetStockUnitNext( player, numTowns+1, c_ZU_Queen, c_stockAlways );
}

//--------------------------------------------------------------------------------------------------
//  ZergTechUp
//--------------------------------------------------------------------------------------------------
void ZergTechUp (int player, int tier) {
    int diff = AIPlayerDifficulty(player);

    if (diff < c_skirMedium) {
        // don't build extra buildings below medium
        return;
    }

    AISetStock( player, 2, c_ZB_Extractor );
    AISetStock( player, 1, c_ZB_SpawningPool );
    AISetStock( player, 1, c_ZB_RoachWarren );
    AISetStock( player, 1, c_ZB_BanelingNest );
    AISetStock( player, 1, c_ZB_EvolutionChamber );

    if (tier >= c_ldPhaseMid) {
        ZergAtEachTown(player, tier);
        AISetStock( player, 1, c_ZB_HydraliskDen );
        AISetStock( player, 1, c_ZB_InfestationPit );
        AISetStock( player, 1, c_ZB_Spire_Alias );
        AISetStock( player, 2, c_ZB_EvolutionChamber );

        if (tier >= c_ldPhaseLate) {
            AISetStock( player, 1, c_ZB_UltraliskCavern );
            AISetStock( player, 1, c_ZB_GreaterSpire );
            AISetStock( player, 2, c_ZB_Spire_Alias );
            
            if (diff > c_skirMedium) {
                // only make a macro hatch above medium
                AISetStock( player, 2, c_ZB_Hatchery_Alias );
            }
        }
    }
}

//--------------------------------------------------------------------------------------------------
//  ProtossBasicEconomy
//--------------------------------------------------------------------------------------------------
void ProtossBasicEconomy (int player, int tier, int minWorkers) {
    int econMin = AIGetMinPeonCount(player, c_townMax);
    if (minWorkers > econMin) {
        minWorkers = econMin;
    }

    AIDefaultEconomy(player, c_PB_Nexus, c_PB_Assimilator, c_PB_Pylon, c_PU_Probe, minWorkers, c_stockAlways);
}

//--------------------------------------------------------------------------------------------------
//  ProtossBasicExpansion
//--------------------------------------------------------------------------------------------------
void ProtossBasicExpansion (int player, int tier, int minerals, int gas) {
    AIDefaultExpansion(player, c_PB_Nexus, minerals, gas, c_expandDefault);
}

//--------------------------------------------------------------------------------------------------
//  ProtossGeneralBuild
//--------------------------------------------------------------------------------------------------
void ProtossGeneralBuild (int player, int tier) {
    if (tier >= c_ldPhaseMid) {
        if (PlayerBeaconIsSet(player, c_beaconDetect)) {
            AISetStock( player, 1, c_PU_Observer );
        }
    }
}

//--------------------------------------------------------------------------------------------------
//  ProtossMacroExpand
//--------------------------------------------------------------------------------------------------
bool ProtossMacroExpand (int player) {
    fixed defenseEval = 0;

    if (AITechCount(player, c_PU_Probe, c_techCountQueuedOrBetter) < 14) {
        return false;
    }
    if (AITechCount(player, c_PB_Nexus, c_techCountQueuedOrBetter) >= 2) {
        return false;
    }
    
    defenseEval = AISelfDefenseThreatEval(c_dtRealSelfThreat, player);
    if (defenseEval >= 120) {
        // don't expand if currently under attack
        return false;
    }

    if (!AIIsExpandingOrHasExpanded(player)) {
        if (!AIHasNearbyOpenExpansion(player)) {
            return false;
        }
        if (!AIHasRes(player,300,0)) {
            AIEnableStock(player);
            return true;
        }

        // we should try to expand
        AIExpand(player, AIGetTownLocation(player, c_townMain), c_PB_Nexus);
    }

    // currently expanding see if we need to save minerals
    if (!AIHasRes(player,500,0)) {
        AIEnableStock(player);
        return true;
    }
    return false; // already saved enough, we're allowed to continure the stock
}

//--------------------------------------------------------------------------------------------------
//  ProtossAtEachTown
//--------------------------------------------------------------------------------------------------
void ProtossAtEachTown (int player, int tier) {
    int i = 0;
    int town;

    while (i < c_townMax) {
        town = i;
        i = i + 1;

        if (AIGetTownState(player, town) != c_townStateEstablished) {
            continue;
        }

        if (AIGetBuildingCountInTown(player, town, c_PB_Nexus, c_techCountCompleteOnly) < 1) {
            continue;
        }

        // make 2 pylons in each town
        if (AIGetBuildingCountInTown(player, town, c_PB_Pylon, c_techCountCompleteOnly) < 2) {
            AISetStockEx(player, town, 1, c_PB_Pylon, c_makeExpanPower, 0);
            AISetStockEx(player, town, 2, c_PB_Pylon, c_makeResourceDefense | c_nearDropoff, 0);
            continue;
        }

        if (AIGetBuildingCountInTown(player, town, c_PB_PhotonCannon, c_techCountCompleteOnly) < 2) {
            AISetStockEx(player, town, 2, c_PB_PhotonCannon, c_makeResourceDefense | c_nearDropoff, 0);
            continue;
        }
    }
}

//--------------------------------------------------------------------------------------------------
//  ProtossTechUp
//--------------------------------------------------------------------------------------------------
void ProtossTechUp (int player, int tier) {
    int diff = AIPlayerDifficulty(player);

    if (diff < c_skirMedium) {
        // don't build extra buildings below medium
        return;
    }

    AISetStock( player, 2, c_PB_Assimilator );
    AISetStock( player, 1, c_PB_Gateway );
    AISetStock( player, 1, c_PB_CyberneticsCore );
    AISetStock( player, 1, c_PB_Forge );

    if (tier >= c_ldPhaseMid) {
        ProtossAtEachTown(player, tier);
        AISetStock( player, 1, c_PB_RoboticsFacility );
        AISetStock( player, 1, c_PB_Stargate );
        AISetStock( player, 1, c_PB_TwilightCouncil );
        AISetStock( player, 3, c_PB_Gateway );
        AISetStock( player, 2, c_PB_Forge );

        if (tier >= c_ldPhaseLate) {
            AISetStock( player, 1, c_PB_TemplarArchives );
            AISetStock( player, 1, c_PB_RoboticsBay );
            AISetStock( player, 1, c_PB_DarkShrine );
            AISetStock( player, 1, c_PB_FleetBeacon );
            AISetStock( player, 2, c_PB_RoboticsFacility );
            AISetStock( player, 2, c_PB_Stargate );
        }
    }
}